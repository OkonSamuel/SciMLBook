<h1 class=title >Introduction to Scientific Machine Learning through Physics-Informed Neural Networks</h1> <h5>Chris Rackauckas</h5> <h5>September 8th, 2020</h5> <h2><a href="https://youtu.be/C3vf9ZFYbjI">Youtube Video Link Part 1</a></h2> <h2><a href="https://youtu.be/hKHl68Fdpq4">Youtube Video Link Part 2</a></h2> <p>Here we will start to dig into what scientific machine learning is all about by looking at physics-informed neural networks. Let&#39;s start by understanding what neural networks really are, why they are used, and what kinds of problems they solve, and then we will use this understanding of a neural network to see how to solve ordinary differential equations with neural networks. For there, we will use this method to regularize neural networks with physical equations, the aforementioned physics-informed neural network, and see how to define neural network architectures that satisfy physical constraints to improve the training process.</p> <h2>Getting Started with Machine Learning: Adding Flux</h2> <p>To add Flux.jl we would do:</p> <pre class='hljl'>
<span class='hljl-p'>]</span><span class='hljl-n'>add</span><span class='hljl-t'> </span><span class='hljl-n'>Flux</span>
</pre> <p>To then use the package we will then use the <code>using</code> command:</p> <pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Flux</span>
</pre> <pre class=julia-error >
ERROR: Failed to precompile Flux &#91;587475ba-b771-5e3f-ad9e-33799f191a9c&#93; to &quot;/home/runner/.julia/compiled/v1.10/Flux/jl_Q82f1P&quot;.
</pre> <p>If you prefer to namespace all commands &#40;like is normally done in Python, i.e. <code>Flux.gradient</code> instead of <code>gradient</code>&#41;, you can use the command:</p> <pre class='hljl'>
<span class='hljl-k'>import</span><span class='hljl-t'> </span><span class='hljl-n'>Flux</span>
</pre> <p>Note that the installation and precompilation of these packages will occur at the <code>add</code> and first <code>using</code> phases, so they may take awhile &#40;subsequent uses will utilize the precompiled form and take a lot less time&#33;&#41;</p> <h2>What is a Neural Network?</h2> <p>A neural network is a function:</p> <p class=math >\[ \text{NN}(x) = W_3\sigma_2(W_2\sigma_1(W_1x + b_1) + b_2) + b_3 \]</p> <p>where we can change the number of layers &#40;<code>&#40;W_i,b_i&#41;</code>&#41; as necessary. Let&#39;s assume we want to approximate some <span class=math >$R^{10} \rightarrow R^5$</span> function. To do this we need to make sure that we start with 10 inputs and arrive at 5 outputs. If we want a bigger middle layer for example, we can do something like &#40;10,32,32,5&#41;. Size changing occurs at the site of the matrix multiplication, which means that we want a 32x10 matrix, then a 32x32 matrix, and finally a 5x32 matrix. This neural network would look like:</p> <pre class='hljl'>
<span class='hljl-n'>W</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nf'>randn</span><span class='hljl-p'>(</span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-ni'>10</span><span class='hljl-p'>),</span><span class='hljl-nf'>randn</span><span class='hljl-p'>(</span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-ni'>32</span><span class='hljl-p'>),</span><span class='hljl-nf'>randn</span><span class='hljl-p'>(</span><span class='hljl-ni'>5</span><span class='hljl-p'>,</span><span class='hljl-ni'>32</span><span class='hljl-p'>)]</span><span class='hljl-t'>
</span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nf'>zeros</span><span class='hljl-p'>(</span><span class='hljl-ni'>32</span><span class='hljl-p'>),</span><span class='hljl-nf'>zeros</span><span class='hljl-p'>(</span><span class='hljl-ni'>32</span><span class='hljl-p'>),</span><span class='hljl-nf'>zeros</span><span class='hljl-p'>(</span><span class='hljl-ni'>5</span><span class='hljl-p'>)]</span>
</pre> <pre class=output >
3-element Vector&#123;Vector&#123;Float64&#125;&#125;:
 &#91;0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 
0.0, 0.0, 0.0, 0.0, 0.0, 0.0&#93;
 &#91;0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 
0.0, 0.0, 0.0, 0.0, 0.0, 0.0&#93;
 &#91;0.0, 0.0, 0.0, 0.0, 0.0&#93;
</pre> <pre class='hljl'>
<span class='hljl-nf'>simpleNN</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>W</span><span class='hljl-p'>[</span><span class='hljl-ni'>3</span><span class='hljl-p'>]</span><span class='hljl-oB'>*</span><span class='hljl-n'>tanh</span><span class='hljl-oB'>.</span><span class='hljl-p'>(</span><span class='hljl-n'>W</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>]</span><span class='hljl-oB'>*</span><span class='hljl-n'>tanh</span><span class='hljl-oB'>.</span><span class='hljl-p'>(</span><span class='hljl-n'>W</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-oB'>*</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>])</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>])</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>[</span><span class='hljl-ni'>3</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-nf'>simpleNN</span><span class='hljl-p'>(</span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>10</span><span class='hljl-p'>))</span>
</pre> <pre class=output >
5-element Vector&#123;Float64&#125;:
   9.729197643883914
   1.502291450680328
   2.9782106167329805
  -0.06433798917412636
 -10.69163213741377
</pre> <p>This is our direct definition of a neural network. Notice that we choose to use <code>tanh</code> as our <strong>activation function</strong> between the layers.</p> <h3>Defining Neural Networks with Flux.jl</h3> <p>One of the main deep learning libraries in Julia is Flux.jl. Flux is an interesting library for scientific machine learning because it is built on top of language-wide <strong>automatic differentiation</strong> libraries, giving rise to a programming paradigm known as <strong>differentiable programming</strong>, which means that one can write a program in a manner that it has easily accessible fast derivatives. However, due to being built on a differentiable programming base, the underlying functionality is simply standard Julia code,</p> <p>To learn how to use the library, consult the documentation. A Google search will bring up the <a href="https://github.com/FluxML/Flux.jl">Flux.jl Github repository</a>. From there, the blue link on the README brings you to <a href="https://fluxml.ai/Flux.jl/stable/">the package documentation</a>. This is common through Julia so it&#39;s a good habit to learn&#33;</p> <p>In the documentation you will find that the way a neural network is defined is through a <code>Chain</code> of layers. A <code>Dense</code> layer is the kind we defined above, which is given by an input size, an output size, and an activation function. For example, the following recreates the neural network that we had above:</p> <pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Flux</span><span class='hljl-t'>
</span><span class='hljl-n'>NN2</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Chain</span><span class='hljl-p'>(</span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>10</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-n'>tanh</span><span class='hljl-p'>),</span><span class='hljl-t'>
           </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>32</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-n'>tanh</span><span class='hljl-p'>),</span><span class='hljl-t'>
           </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>32</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>5</span><span class='hljl-p'>))</span><span class='hljl-t'>
</span><span class='hljl-nf'>NN2</span><span class='hljl-p'>(</span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>10</span><span class='hljl-p'>))</span>
</pre> <pre class=julia-error >
ERROR: Failed to precompile Flux &#91;587475ba-b771-5e3f-ad9e-33799f191a9c&#93; to &quot;/home/runner/.julia/compiled/v1.10/Flux/jl_v4aQyk&quot;.
</pre> <p>Notice that Flux.jl as a library is written in pure Julia, which means that every piece of this syntax is just sugar over some Julia code that we can specialize ourselves &#40;this is the advantage of having a language fast enough for the implementation of the library and the use of the library&#33;&#41;</p> <p>For example, the activation function is just a scalar Julia function. If we wanted to replace it by something like the quadratic function, we can just use an <strong>anonymous function</strong> to define the scalar function we would like to use:</p> <pre class='hljl'>
<span class='hljl-n'>NN3</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Chain</span><span class='hljl-p'>(</span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>10</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-n'>x</span><span class='hljl-oB'>-&gt;</span><span class='hljl-n'>x</span><span class='hljl-oB'>^</span><span class='hljl-ni'>2</span><span class='hljl-p'>),</span><span class='hljl-t'>
            </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>32</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-n'>x</span><span class='hljl-oB'>-&gt;</span><span class='hljl-nf'>max</span><span class='hljl-p'>(</span><span class='hljl-ni'>0</span><span class='hljl-p'>,</span><span class='hljl-n'>x</span><span class='hljl-p'>)),</span><span class='hljl-t'>
            </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>32</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>5</span><span class='hljl-p'>))</span><span class='hljl-t'>
</span><span class='hljl-nf'>NN3</span><span class='hljl-p'>(</span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>10</span><span class='hljl-p'>))</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;Dense&#96; not defined
</pre> <p>The second activation function there is what&#39;s known as a <code>relu</code>. A <code>relu</code> can be good to use because it&#39;s an exceptionally fast operation and satisfies a form of the universal approximation theorem &#40;UAT&#41;. However, a downside is that its derivative is not continuous, which could impact the numerical properties of some algorithms, and thus it&#39;s widely used throughout standard machine learning but we&#39;ll see reasons why it may be disadvantageous in some cases in scientific machine learning.</p> <h3>Digging into the Construction of a Neural Network Library</h3> <p>Again, as mentioned before, this neural network <code>NN2</code> is simply a function:</p> <pre class='hljl'>
<span class='hljl-nf'>simpleNN</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>W</span><span class='hljl-p'>[</span><span class='hljl-ni'>3</span><span class='hljl-p'>]</span><span class='hljl-oB'>*</span><span class='hljl-n'>tanh</span><span class='hljl-oB'>.</span><span class='hljl-p'>(</span><span class='hljl-n'>W</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>]</span><span class='hljl-oB'>*</span><span class='hljl-n'>tanh</span><span class='hljl-oB'>.</span><span class='hljl-p'>(</span><span class='hljl-n'>W</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-oB'>*</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>])</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>])</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>[</span><span class='hljl-ni'>3</span><span class='hljl-p'>]</span>
</pre> <pre class=output >
simpleNN &#40;generic function with 1 method&#41;
</pre> <p>Let&#39;s dig into the library and see how that&#39;s represented and really understand the construction of a deep learning library. First, let&#39;s figure out where <code>Dense</code> comes from and what it does.</p> <pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>InteractiveUtils</span><span class='hljl-t'>
</span><span class='hljl-nd'>@which</span><span class='hljl-t'> </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>10</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-n'>tanh</span><span class='hljl-p'>)</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;Dense&#96; not defined
</pre> <p>If we go to that spot of the code, we find the following:</p> <pre class='hljl'>
<span class='hljl-k'>struct</span><span class='hljl-t'> </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>{</span><span class='hljl-n'>F</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>M</span><span class='hljl-oB'>&lt;:</span><span class='hljl-n'>AbstractMatrix</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>B</span><span class='hljl-p'>}</span><span class='hljl-t'>
  </span><span class='hljl-n'>weight</span><span class='hljl-oB'>::</span><span class='hljl-n'>M</span><span class='hljl-t'>
  </span><span class='hljl-n'>bias</span><span class='hljl-oB'>::</span><span class='hljl-n'>B</span><span class='hljl-t'>
  </span><span class='hljl-n'>σ</span><span class='hljl-oB'>::</span><span class='hljl-n'>F</span><span class='hljl-t'>
  </span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-n'>W</span><span class='hljl-oB'>::</span><span class='hljl-n'>M</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>bias</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-kc'>true</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>σ</span><span class='hljl-oB'>::</span><span class='hljl-n'>F</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>identity</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-n'>where</span><span class='hljl-t'> </span><span class='hljl-p'>{</span><span class='hljl-n'>M</span><span class='hljl-oB'>&lt;:</span><span class='hljl-n'>AbstractMatrix</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>F</span><span class='hljl-p'>}</span><span class='hljl-t'>
    </span><span class='hljl-n'>b</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>create_bias</span><span class='hljl-p'>(</span><span class='hljl-n'>W</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>bias</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-nf'>size</span><span class='hljl-p'>(</span><span class='hljl-n'>W</span><span class='hljl-p'>,</span><span class='hljl-ni'>1</span><span class='hljl-p'>))</span><span class='hljl-t'>
    </span><span class='hljl-nf'>new</span><span class='hljl-p'>{</span><span class='hljl-n'>F</span><span class='hljl-p'>,</span><span class='hljl-n'>M</span><span class='hljl-p'>,</span><span class='hljl-nf'>typeof</span><span class='hljl-p'>(</span><span class='hljl-n'>b</span><span class='hljl-p'>)}(</span><span class='hljl-n'>W</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>σ</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>((</span><span class='hljl-kp'>in</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>out</span><span class='hljl-p'>)</span><span class='hljl-oB'>::</span><span class='hljl-nf'>Pair</span><span class='hljl-p'>{</span><span class='hljl-oB'>&lt;:</span><span class='hljl-n'>Integer</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-oB'>&lt;:</span><span class='hljl-n'>Integer</span><span class='hljl-p'>},</span><span class='hljl-t'> </span><span class='hljl-n'>σ</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>identity</span><span class='hljl-p'>;</span><span class='hljl-t'>
               </span><span class='hljl-n'>init</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>glorot_uniform</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>bias</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-kc'>true</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-nf'>init</span><span class='hljl-p'>(</span><span class='hljl-n'>out</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-p'>),</span><span class='hljl-t'> </span><span class='hljl-n'>bias</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>σ</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre> <p>First, <code>Dense</code> defines a struct in Julia. This struct just holds a weight matrix <code>W</code>, a bias vector <code>b</code>, and an activation function <code>σ</code>. It also defines an <strong>inner constructor</strong> that ensures that a created <code>Dense</code> object will have the desired properties and types for its fields. The function called <code>Dense</code> that is defined next, outside the <code>struct</code>, is what&#39;s known as an <strong>outer constructor</strong> which provides a more convenient way to create a <code>Dense</code> object. If you give it a <code>Pair</code> of integers &#40;and optionally an activation function which defaults to <code>identity</code>&#41;, then what it will do is take random initial <code>W</code> and <code>b</code> matrices &#40;according to the <code>glorot_uniform</code> distribution for <code>W</code> and <code>zeros</code> for <code>b</code>&#41;, and then it will build the type with those matrices.</p> <p>The next portion might be new. We give it here in the simpler form it had in earlier versions of the Flux package, so that we can concentrate on the essential:</p> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>Dense</span><span class='hljl-p'>)(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-n'>AbstractArray</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>W</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>σ</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>W</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>σ</span><span class='hljl-t'>
  </span><span class='hljl-n'>σ</span><span class='hljl-oB'>.</span><span class='hljl-p'>(</span><span class='hljl-n'>W</span><span class='hljl-oB'>*</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre> <p>This defines what is known as a <strong>callable struct</strong>, or a functor. It defines the dispatch for how calls work on the struct. As a quick demonstration, let&#39;s define a type <code>MyCallableStruct</code> with a field <code>x</code>, and then make instances of <code>A</code> be the function <code>x&#43;y</code>:</p> <pre class='hljl'>
<span class='hljl-k'>struct</span><span class='hljl-t'> </span><span class='hljl-n'>MyCallableStruct</span><span class='hljl-t'>
  </span><span class='hljl-n'>x</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>MyCallableStruct</span><span class='hljl-p'>)(</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>x</span><span class='hljl-oB'>+</span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-n'>a</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>MyCallableStruct</span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>a</span><span class='hljl-p'>(</span><span class='hljl-ni'>3</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
5
</pre> <p>If you&#39;re familiar with object-oriented programming, this is similar to using an object in a way that references the <code>self</code>, though it&#39;s a bit more general due to allowing dispatching, i.e. this can then dependent on the input types as well.</p> <p>So let&#39;s look at <code>Dense</code> with this in mind:</p> <pre class='hljl'>
<span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-n'>a</span><span class='hljl-oB'>::</span><span class='hljl-n'>Dense</span><span class='hljl-p'>)(</span><span class='hljl-n'>x</span><span class='hljl-oB'>::</span><span class='hljl-n'>AbstractArray</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>W</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>σ</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>W</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>b</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>a</span><span class='hljl-oB'>.</span><span class='hljl-n'>σ</span><span class='hljl-t'>
  </span><span class='hljl-n'>σ</span><span class='hljl-oB'>.</span><span class='hljl-p'>(</span><span class='hljl-n'>W</span><span class='hljl-oB'>*</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>b</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre> <p>This means that <code>Dense</code> is a function that takes in an <code>x</code> and computes <code>σ.&#40;W*x.&#43;b&#41;</code>, which is precisely how we defined the layer before&#33; To see that this is just a function, let&#39;s call it directly:</p> <pre class='hljl'>
<span class='hljl-n'>denselayer_f</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>32</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-n'>tanh</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>denselayer_f</span><span class='hljl-p'>(</span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>32</span><span class='hljl-p'>))</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;Dense&#96; not defined
</pre> <p>So okay, <code>Dense</code> objects are just functions that have weight and bias matrices inside of them. Now what does <code>Chain</code> do?</p> <pre class='hljl'>
<span class='hljl-nd'>@which</span><span class='hljl-t'> </span><span class='hljl-nf'>Chain</span><span class='hljl-p'>(</span><span class='hljl-ni'>1</span><span class='hljl-p'>,</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-ni'>3</span><span class='hljl-p'>)</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;Chain&#96; not defined
</pre> <p>Again, for our explanations here we will look at the slightly simpler code From and earlier version of the Flux package:</p> <pre class='hljl'>
<span class='hljl-k'>struct</span><span class='hljl-t'> </span><span class='hljl-nf'>Chain</span><span class='hljl-p'>{</span><span class='hljl-n'>T</span><span class='hljl-oB'>&lt;:</span><span class='hljl-n'>Tuple</span><span class='hljl-p'>}</span><span class='hljl-t'>
  </span><span class='hljl-n'>layers</span><span class='hljl-oB'>::</span><span class='hljl-n'>T</span><span class='hljl-t'>
  </span><span class='hljl-nf'>Chain</span><span class='hljl-p'>(</span><span class='hljl-n'>xs</span><span class='hljl-oB'>...</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>new</span><span class='hljl-p'>{</span><span class='hljl-nf'>typeof</span><span class='hljl-p'>(</span><span class='hljl-n'>xs</span><span class='hljl-p'>)}(</span><span class='hljl-n'>xs</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>

</span><span class='hljl-nf'>applychain</span><span class='hljl-p'>(</span><span class='hljl-oB'>::</span><span class='hljl-nf'>Tuple</span><span class='hljl-p'>{},</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'>
</span><span class='hljl-nf'>applychain</span><span class='hljl-p'>(</span><span class='hljl-n'>fs</span><span class='hljl-oB'>::</span><span class='hljl-n'>Tuple</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>applychain</span><span class='hljl-p'>(</span><span class='hljl-nf'>tail</span><span class='hljl-p'>(</span><span class='hljl-n'>fs</span><span class='hljl-p'>),</span><span class='hljl-t'> </span><span class='hljl-nf'>first</span><span class='hljl-p'>(</span><span class='hljl-n'>fs</span><span class='hljl-p'>)(</span><span class='hljl-n'>x</span><span class='hljl-p'>))</span><span class='hljl-t'>

</span><span class='hljl-p'>(</span><span class='hljl-n'>c</span><span class='hljl-oB'>::</span><span class='hljl-n'>Chain</span><span class='hljl-p'>)(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>applychain</span><span class='hljl-p'>(</span><span class='hljl-n'>c</span><span class='hljl-oB'>.</span><span class='hljl-n'>layers</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span>
</pre> <p>Let&#39;s now dig into this. The <code>...</code> is known that the <strong>slurp operator</strong>, which allows for &quot;slurping up&quot; multiple arguments into a single object <code>xs</code>. For example:</p> <pre class='hljl'>
<span class='hljl-nf'>slurper</span><span class='hljl-p'>(</span><span class='hljl-n'>xs</span><span class='hljl-oB'>...</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nd'>@show</span><span class='hljl-t'> </span><span class='hljl-n'>xs</span><span class='hljl-t'>
</span><span class='hljl-nf'>slurper</span><span class='hljl-p'>(</span><span class='hljl-ni'>1</span><span class='hljl-p'>,</span><span class='hljl-ni'>2</span><span class='hljl-p'>,</span><span class='hljl-ni'>3</span><span class='hljl-p'>,</span><span class='hljl-ni'>4</span><span class='hljl-p'>,</span><span class='hljl-ni'>5</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
xs &#61; &#40;1, 2, 3, 4, 5&#41;
&#40;1, 2, 3, 4, 5&#41;
</pre> <p>We see that slurps the inputs up into a <code>Tuple</code>, which is an immutable data store. &#40;Note: Tuples are stack-allocated if inferred and is the internal data store of the compiler itself, and compiler inference can know exactly the size and the type of each individual object, so this does not have an overhead if fully inferred&#41;.</p> <p>The function <code>Chain&#40;xs...&#41; &#61; new&#123;typeof&#40;xs&#41;&#125;&#40;xs&#41;</code> is an <strong>inner constructor</strong> which builds a new instance of <code>Chain</code> where <code>layers</code> is a tuple of the inputs. This means that in our case where we put a bunch of <code>Dense</code> inside of there, <code>layers</code> is a tuple of functions. What does <code>Chain</code> do? Let&#39;s look at its call:</p> <pre class='hljl'>
<span class='hljl-p'>(</span><span class='hljl-n'>c</span><span class='hljl-oB'>::</span><span class='hljl-n'>Chain</span><span class='hljl-p'>)(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>applychain</span><span class='hljl-p'>(</span><span class='hljl-n'>c</span><span class='hljl-oB'>.</span><span class='hljl-n'>layers</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span>
</pre> <p>This takes the tuple of functions and then does <code>applychain</code> on it.</p> <pre class='hljl'>
<span class='hljl-nf'>applychain</span><span class='hljl-p'>(</span><span class='hljl-oB'>::</span><span class='hljl-nf'>Tuple</span><span class='hljl-p'>{},</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'>
</span><span class='hljl-nf'>applychain</span><span class='hljl-p'>(</span><span class='hljl-n'>fs</span><span class='hljl-oB'>::</span><span class='hljl-n'>Tuple</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>applychain</span><span class='hljl-p'>(</span><span class='hljl-nf'>tail</span><span class='hljl-p'>(</span><span class='hljl-n'>fs</span><span class='hljl-p'>),</span><span class='hljl-t'> </span><span class='hljl-nf'>first</span><span class='hljl-p'>(</span><span class='hljl-n'>fs</span><span class='hljl-p'>)(</span><span class='hljl-n'>x</span><span class='hljl-p'>))</span>
</pre> <p><code>applychain</code> is a recursive function which applies the first element of the tuple onto <code>x</code>, then it calls <code>applychain</code> to call the second function onto <code>x</code>, repeatedly until there are no more functions in which case it returns <code>x</code>. This means that <code>applychain</code> is simply doing <code>h&#40;g&#40;f&#40;x&#41;&#41;&#41;</code> on the tuple of functions <code>&#40;f,g,h&#41;</code>&#33; We can thus see that this library function is exactly equivalent to the neural network we defined by hand, just put together in a different form to give a nice user interface.</p> <h4>Detail: Recursion?</h4> <p>But there&#39;s one more detail... why recursion? If you define a function, look at its type:</p> <pre class='hljl'>
<span class='hljl-nf'>ff</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-n'>x</span><span class='hljl-oB'>+</span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-nf'>typeof</span><span class='hljl-p'>(</span><span class='hljl-n'>ff</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
typeof&#40;ff&#41; &#40;singleton type of function ff, subtype of Function&#41;
</pre> <p>Notice that its type is simply <code>typeof&#40;ff&#41;</code> which is unique to the function, i.e. every single function is its own struct. In fact, given what we just learned, it wouldn&#39;t be a surprise to learn that is exactly what a function is in Julia&#33; A function definition lowers at the parser level to something like:</p> <pre class='hljl'>
<span class='hljl-k'>struct</span><span class='hljl-t'> </span><span class='hljl-n'>ff2</span><span class='hljl-t'> </span><span class='hljl-oB'>&lt;:</span><span class='hljl-t'> </span><span class='hljl-n'>Function</span><span class='hljl-t'> </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-p'>(</span><span class='hljl-n'>_</span><span class='hljl-oB'>::</span><span class='hljl-n'>ff2</span><span class='hljl-p'>)(</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>y</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>2</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>y</span><span class='hljl-t'>
</span><span class='hljl-kd'>const</span><span class='hljl-t'> </span><span class='hljl-n'>ff</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>ff2</span><span class='hljl-p'>()</span>
</pre> <p>This means that the primitive operation here that everything really comes down to is calls on structs. Why is this done with unique <strong>singleton</strong> types? &#40;Singleton types are types where every instance is equivalent&#41;. Well, if we want the compiler to be able to optimize with respect to which function we are handling inside of another function, then we need &quot;what function we are dealing with&quot; as compile-time information, which necessitates being type information.</p> <p>Tuples are contravariant and heterogeneously typed with a parameter per internal object. For example:</p> <pre class='hljl'>
<span class='hljl-n'>tup</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-ni'>1</span><span class='hljl-p'>,</span><span class='hljl-s'>&quot;1&quot;</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>typeof</span><span class='hljl-p'>(</span><span class='hljl-n'>tup</span><span class='hljl-p'>)</span>
</pre> <pre class=output >
Tuple&#123;Float64, Int64, String&#125;
</pre> <p>This means that it is possible to infer outputs of a tuple even if it&#39;s heterogeneously typed by making good use of constant literals. For example, the expression <code>tup&#91;1&#93;</code> will be inferred to have the output <code>Float64</code>. However, note that if <code>i</code> is not a compile-time constant, then <code>tup&#91;i&#93;</code> cannot be inferred since, given what the compiler knows, the output could be either a <code>Float64</code>, an <code>Int64</code>, or a <code>String</code>.</p> <p>So now let&#39;s think back to our tuple of functions. By what we described before, <code>tup &#61; &#40;f,g,h&#41;</code> is going to have a different type for each of the functions and thus could not specialize on the inputs if we used <code>tup&#91;i&#93;</code>. Therefore:</p> <pre class='hljl'>
<span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-nf'>length</span><span class='hljl-p'>(</span><span class='hljl-n'>tup</span><span class='hljl-p'>)</span><span class='hljl-t'>
  </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>tup</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>](</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span>
</pre> <p>would be slow &#40;if the function call cost is small compared to the dispatch cost of about 100ns. This is not always the case, but should be considered in many instances&#33;&#41;. So how can you get around it? Well, if everything was constant literals then this would specialize:</p> <pre class='hljl'>
<span class='hljl-n'>tup</span><span class='hljl-p'>[</span><span class='hljl-ni'>3</span><span class='hljl-p'>](</span><span class='hljl-n'>tup</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>](</span><span class='hljl-n'>tup</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>](</span><span class='hljl-n'>x</span><span class='hljl-p'>)))</span>
</pre> <p>would fully specialize and infer, and the compiler would have full knowledge of the entire call chain as if it were written out as straightline code. Now if we look at the recursion again:</p> <pre class='hljl'>
<span class='hljl-nf'>applychain</span><span class='hljl-p'>(</span><span class='hljl-oB'>::</span><span class='hljl-nf'>Tuple</span><span class='hljl-p'>{},</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'>
</span><span class='hljl-nf'>applychain</span><span class='hljl-p'>(</span><span class='hljl-n'>fs</span><span class='hljl-oB'>::</span><span class='hljl-n'>Tuple</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>applychain</span><span class='hljl-p'>(</span><span class='hljl-nf'>tail</span><span class='hljl-p'>(</span><span class='hljl-n'>fs</span><span class='hljl-p'>),</span><span class='hljl-t'> </span><span class='hljl-nf'>first</span><span class='hljl-p'>(</span><span class='hljl-n'>fs</span><span class='hljl-p'>)(</span><span class='hljl-n'>x</span><span class='hljl-p'>))</span>
</pre> <p>we see that, at compile-time, we know that <code>typeof&#40;&#40;f,g,h&#41;&#41; &#61; Tuple&#123;typeof&#40;f&#41;,typeof&#40;g&#41;,typeof&#40;h&#41;&#125;</code>, and so we know that the first <code>first&#40;fs&#41;</code> will be <code>f</code>, and can specialize on this. We know then that <code>tail&#40;fs&#41;</code> has to be the <code>&#40;g,h&#41;</code> and so then we recurse and know that <code>g</code> is first and ... This means that this scheme is equivalent to have written out <code>xs&#91;3&#93;&#40;xs&#91;2&#93;&#40;xs&#91;1&#93;&#40;x&#41;&#41;&#41;</code> and is thus generating code perfectly specialized to the order and amount of functions we had put into the <code>Chain</code>. This kind of abstraction, an abstraction where all of the overhead compiles away, is known as a <strong>zero-cost abstraction</strong>.</p> <p>&#40;Note that technically, there is a cost since the compiler has to unravel this chain of events.&#41;</p> <h3>Training Neural Networks</h3> <p>Now let&#39;s get into training neural networks. &quot;Training&quot; a neural network is simply the process of finding weights that minimize a loss function. For example, let&#39;s say we wanted to make our neural network be the constant function <code>1</code> for any input <span class=math >$x \in [0,1]^{10}$</span>. We can then write the loss function:</p> <pre class='hljl'>
<span class='hljl-n'>NN</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Chain</span><span class='hljl-p'>(</span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>10</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-n'>tanh</span><span class='hljl-p'>),</span><span class='hljl-t'>
           </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>32</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-n'>tanh</span><span class='hljl-p'>),</span><span class='hljl-t'>
           </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>32</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>5</span><span class='hljl-p'>))</span><span class='hljl-t'>
</span><span class='hljl-nf'>loss</span><span class='hljl-p'>()</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>sum</span><span class='hljl-p'>(</span><span class='hljl-n'>abs2</span><span class='hljl-p'>,</span><span class='hljl-nf'>sum</span><span class='hljl-p'>(</span><span class='hljl-n'>abs2</span><span class='hljl-p'>,</span><span class='hljl-nf'>NN</span><span class='hljl-p'>(</span><span class='hljl-nf'>rand</span><span class='hljl-p'>(</span><span class='hljl-ni'>10</span><span class='hljl-p'>))</span><span class='hljl-oB'>.-</span><span class='hljl-ni'>1</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>loss</span><span class='hljl-p'>()</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;Dense&#96; not defined
</pre> <p>This loss function takes 100 random points in <span class=math >$[0,1]^{10}$</span> and then computes the output of the neural network minus <code>1</code> on each of the values, and sums up the squared values &#40;<code>abs2</code>&#41;. Why the squared values? This means that every computed loss value is positive, and so we know that by decreasing the loss this means that, on average our neural network outputs are closer to 1. What are the weights? Since we&#39;re using the Flux callable struct style from above, the weights are those inside of the <code>NN</code> chain object, which we can inspect:</p> <pre class='hljl'>
<span class='hljl-n'>NN</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>]</span><span class='hljl-oB'>.</span><span class='hljl-n'>weight</span><span class='hljl-t'> </span><span class='hljl-cs'># The W matrix of the first layer</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;NN&#96; not defined
</pre> <p>Now let&#39;s grab all of the parameters together:</p> <pre class='hljl'>
<span class='hljl-n'>p</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>Flux</span><span class='hljl-oB'>.</span><span class='hljl-nf'>params</span><span class='hljl-p'>(</span><span class='hljl-n'>NN</span><span class='hljl-p'>)</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;Flux&#96; not defined
</pre> <p>That&#39;s a helper function on <code>Chain</code> which recursively gathers all of the defining parameters. Let&#39;s now find the optimal values <code>p</code> which cause the neural network to be the constant <code>1</code> function:</p> <pre class='hljl'>
<span class='hljl-n'>Flux</span><span class='hljl-oB'>.</span><span class='hljl-nf'>train!</span><span class='hljl-p'>(</span><span class='hljl-n'>loss</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>p</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>Iterators</span><span class='hljl-oB'>.</span><span class='hljl-nf'>repeated</span><span class='hljl-p'>((),</span><span class='hljl-t'> </span><span class='hljl-ni'>10000</span><span class='hljl-p'>),</span><span class='hljl-t'> </span><span class='hljl-nf'>ADAM</span><span class='hljl-p'>(</span><span class='hljl-nfB'>0.1</span><span class='hljl-p'>))</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;Flux&#96; not defined
</pre> <p>Now let&#39;s check the loss:</p> <pre class='hljl'>
<span class='hljl-nf'>loss</span><span class='hljl-p'>()</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;loss&#96; not defined
</pre> <p>This means that <code>NN&#40;x&#41;</code> is now a very good function approximator to <code>f&#40;x&#41; &#61; ones&#40;5&#41;</code>&#33;</p> <h3>So Why Machine Learning? Why Neural Networks?</h3> <p>All we did was find parameters that made <code>NN&#40;x&#41;</code> act like a function <code>f&#40;x&#41;</code>. How does that relate to machine learning? Well, in any case where one is acting on data <code>&#40;x,y&#41;</code>, the idea is to assume that there exists some underlying mathematical model <code>f&#40;x&#41; &#61; y</code>. If we had perfect knowledge of what <code>f</code> is, then from only the information of <code>x</code> we can then predict what <code>y</code> would be. The inference problem is to then figure out what function <code>f</code> should be. Therefore, machine learning on data is simply this problem of finding an approximator to some unknown function&#33;</p> <p>So why neural networks? Neural networks satisfy two properties. The first of which is known as the Universal Approximation Theorem &#40;UAT&#41;, which in simple non-mathematical language means that, for any ϵ of accuracy, if your neural network is large enough &#40;has enough layers, the weight matrices are large enough&#41;, then it can approximate <strong>any</strong> &#40;nice&#41; function <code>f</code> within that ϵ. Therefore, we can reduce the problem of finding missing functions, the problem of machine learning, to a problem of finding the weights of neural networks, which is a well-defined mathematical optimization problem.</p> <p>Why neural networks specifically? That&#39;s a fairly good question, since there are many other functions with this property. For example, you will have learned from analysis that <span class=math >$a_0 + a_1 x + a_2 x^2 + \ldots$</span> arbitrary polynomials can be used to approximate any analytic function &#40;this is the Taylor series&#41;. Similarly, a Fourier series</p> <p class=math >\[ f(x) = a_0 + \sum_k b_k \cos(kx) + c_k \sin(kx) \]</p> <p>can approximate any continuous function <code>f</code> &#40;and discontinuous functions also can have convergence, etc. these are the details of a harmonic analysis course&#41;.</p> <p>That&#39;s all for one dimension. How about two dimensional functions? It turns out it&#39;s not difficult to prove that tensor products of universal approximators will give higher dimensional universal approximators. So for example, tensoring together two polynomials:</p> <p class=math >\[ a_0 + a_1 x + a_2 y + a_3 x y + a_4 x^2 y + a_5 x y^2 + a_6 x^2 y^2 + \ldots \]</p> <p>will give a two-dimensional function approximator. But notice how we have to resolve every combination of terms. This means that if we used <code>n</code> coefficients in each dimension <code>d</code>, the total number of coefficients to build a <code>d</code>-dimensional universal approximator from one-dimensional objects would need <span class=math >$n^d$</span> coefficients. This exponential growth is known as <strong>the curse of dimensionality</strong>.</p> <p>The second property of neural networks that makes them applicable to machine learning is that they overcome the curse of dimensionality. The proofs in this area <a href="https://arxiv.org/abs/1908.10828">can be a little difficult to parse</a>, but what they boil down to is proving in many cases that the growth of neural networks to sufficiently approximate a <code>d</code>-dimensional function grows as a polynomial of <code>d</code>, rather than exponential. This means that there&#39;s some dimensional cutoff where for <span class=math >$d>cutoff$</span> it is more efficient to use a neural network. This can be problem-specific, but generally it tends to be the case at least by 8 or 10 dimensions.</p> <p>Neural networks have a few other properties to consider as well:</p> <ol> <li><p>The assumptions of the neural network can be encoded into the neural architectures. A neural network where the last layer has an activation function <code>x-&gt;x^2</code> is a neural network where all outputs are positive. This means that if you want to find a positive function, you can make the optimization easier by enforcing this constraint. A lot of other constraints can be enforced, like <code>tanh</code> activation functions can make the neural network be a smooth &#40;all derivatives finite&#41; function, or other activations can cause finite numbers of learnable discontinuities.</p> <li><p>Generating higher dimensional forms from one dimensional forms does not have good symmetry. For example, the two-dimensional tensor Fourier basis does not have a good way to represent <span class=math >$sin(xy)$</span>. This property of the approximator is called &#40;non&#41;isotropy and more detail can be found in <a href="https://www.youtube.com/watch?v&#61;JngdaWe3-gg">this wonderful talk about function approximation for multidimensional integration &#40;cubature&#41;</a>. Neural networks are naturally not aligned to a basis.</p> <li><p>Neural networks are &quot;easy&quot; to compute. There&#39;s good software for them, GPU-acceleration, and all other kinds of tooling that make them particularly simple to use.</p> <li><p>There are proofs that in many scenarios for neural networks <a href="https://arxiv.org/abs/2006.05900">the local minima are the global minima</a>, meaning that local optimization is sufficient for training a neural network. Global optimization &#40;which we will cover later in the course&#41; is much more expensive than local methods like gradient descent, and thus this can be a good property to abuse for faster computation.</p> </ol> <h3>From Machine Learning to Scientific Machine Learning: Structure and Science</h3> <p>This understanding of a neural network and their libraries directly bridges to the understanding of scientific machine learning and the computation done in the field. In scientific machine learning, neural networks and machine learning are used as the basis to solve problems in scientific computing. <a href="https://en.wikipedia.org/wiki/Computational_science">Scientific computing, as a discipline also known as Computational Science, is a field of study which focuses on scientific simulation, using tools such as differential equations to investigate physical, biological, and other phenomena</a>.</p> <p>What we wish to do in scientific machine learning is use these properties of neural networks to improve the way that we investigate our scientific models.</p> <h4>Aside: Why Differential Equations?</h4> <p>Why do differential equations come up so often in as the model in the scientific context? This is a deep question with quite a simple answer. Essentially, all scientific experiments always have to test how things change. For example, you take a system now, you change it, and your measurement is how the changes you made caused changes in the system. This boils down to gather information about how, for some arbitrary system <span class=math >$y = f(x)$</span>, how <span class=math >$\Delta x$</span> is related to <span class=math >$\Delta y$</span>. Thus what you learn from scientific experiments, what is codified as scientific laws, is not &quot;the answer&quot;, but the answer to how things change. This process of writing down equations by describing how they change precisely gives differential equations.</p> <h2>Solving ODEs with Neural Networks: The Physics-Informed Neural Network</h2> <p>Now let&#39;s get to our first true SciML application: solving ordinary differential equations with neural networks. The process of solving a differential equation with a neural network, or using a differential equation as a regularizer in the loss function, is known as a <strong>physics-informed neural network</strong>, since this allows for physical equations to guide the training of the neural network in circumstances where data might be lacking.</p> <h3>Background: A Method for Solving Ordinary Differential Equations with Neural Networks</h3> <p><a href="https://arxiv.org/pdf/physics/9705023.pdf">This is a result first due to Lagaris et. al from 1998</a>. The idea is to solve differential equations using neural networks by representing the solution by a neural network and training the resulting network to satisfy the conditions required by the differential equation.</p> <p>Let&#39;s say we want to solve a system of ordinary differential equations</p> <p class=math >\[ u' = f(u,t) \]</p> <p>with <span class=math >$t \in [0,1]$</span> and a known initial condition <span class=math >$u(0)=u_0$</span>. To solve this, we approximate the solution by a neural network:</p> <p class=math >\[ NN(t) \approx u(t) \]</p> <p>If <span class=math >$NN(t)$</span> was the true solution, then it would hold that <span class=math >$NN'(t) = f(NN(t),t)$</span> for all <span class=math >$t$</span>. Thus we turn this condition into our loss function. This motivates the loss function:</p> <p class=math >\[ L(p) = \sum_i \left(\frac{dNN(t_i)}{dt} - f(NN(t_i),t_i) \right)^2 \]</p> <p>The choice of <span class=math >$t_i$</span> could be done in many ways: it can be random, it can be a grid, etc. Anyways, when this loss function is minimized &#40;gradients computed with standard reverse-mode automatic differentiation&#41;, then we have that <span class=math >$\frac{dNN(t_i)}{dt} \approx f(NN(t_i),t_i)$</span> and thus <span class=math >$NN(t)$</span> approximately solves the differential equation.</p> <p>Note that we still have to handle the initial condition. One simple way to do this is to add an initial condition term to the cost function. This would look like:</p> <p class=math >\[ L(p) = (NN(0) - u_0)^2 + \sum_i \left(\frac{dNN(t_i)}{dt} - f(NN(t_i),t_i) \right)^2 \]</p> <p>While that would work, it can be more efficient to encode the initial condition into the function itself so that it&#39;s trivially satisfied for any possible set of parameters. For example, instead of directly using a neural network, we can use:</p> <p class=math >\[ g(t) = u_0 + tNN(t) \]</p> <p>as our solution. Notice that <span class=math >$g(t)$</span> is thus a universal approximator for all continuous functions such that <span class=math >$g(0)=u_0$</span> &#40;this is a property one should prove&#33;&#41;. Since <span class=math >$g(t)$</span> will always satisfy the initial condition, we can train <span class=math >$g(t)$</span> to satisfy the derivative function then it will automatically be a solution to the derivative function. In this sense, we can use the loss function:</p> <p class=math >\[ L(p) = \sum_i \left(\frac{dg(t_i)}{dt} - f(g(t_i),t_i) \right)^2 \]</p> <p>where <span class=math >$p$</span> are the parameters that define <span class=math >$g$</span>, which in turn are the parameters which define the neural network <span class=math >$NN$</span> that define <span class=math >$g$</span>. Thus this reduces down, once again, to simply finding weights which minimize a loss function&#33;</p> <h3>Coding Up the Method</h3> <p>Now let&#39;s implement this method with Flux. Let&#39;s define a neural network to be the <code>NN&#40;t&#41;</code> above. To make the problem easier, let&#39;s look at the ODE:</p> <p class=math >\[ u' = \cos 2\pi t \]</p> <p>and approximate it with the neural network from a scalar to a scalar:</p> <pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Flux</span><span class='hljl-t'>
</span><span class='hljl-n'>NNODE</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Chain</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>-&gt;</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>x</span><span class='hljl-p'>],</span><span class='hljl-t'> </span><span class='hljl-cs'># Take in a scalar and transform it into an array</span><span class='hljl-t'>
           </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>1</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-n'>tanh</span><span class='hljl-p'>),</span><span class='hljl-t'>
           </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>32</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-p'>),</span><span class='hljl-t'>
           </span><span class='hljl-n'>first</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-cs'># Take first value, i.e. return a scalar</span><span class='hljl-t'>
</span><span class='hljl-nf'>NNODE</span><span class='hljl-p'>(</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>)</span>
</pre> <pre class=julia-error >
ERROR: Failed to precompile Flux &#91;587475ba-b771-5e3f-ad9e-33799f191a9c&#93; to &quot;/home/runner/.julia/compiled/v1.10/Flux/jl_roogSd&quot;.
</pre> <p>Instead of directly approximating the neural network, we will use the transformed equation that is forced to satisfy the boundary conditions. Using <code>u0&#61;1.0</code>, we have the function:</p> <pre class='hljl'>
<span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>t</span><span class='hljl-oB'>*</span><span class='hljl-nf'>NNODE</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-nfB'>1f0</span>
</pre> <pre class=output >
g &#40;generic function with 2 methods&#41;
</pre> <p>as our universal approximator. Thus, for this to be a function that satisfies</p> <p class=math >\[ g' = \cos 2\pi t \]</p> <p>we would need that:</p> <pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Statistics</span><span class='hljl-t'>
</span><span class='hljl-n'>ϵ</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>sqrt</span><span class='hljl-p'>(</span><span class='hljl-nf'>eps</span><span class='hljl-p'>(</span><span class='hljl-n'>Float32</span><span class='hljl-p'>))</span><span class='hljl-t'>
</span><span class='hljl-nf'>loss</span><span class='hljl-p'>()</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>mean</span><span class='hljl-p'>(</span><span class='hljl-nf'>abs2</span><span class='hljl-p'>(((</span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-oB'>+</span><span class='hljl-n'>ϵ</span><span class='hljl-p'>)</span><span class='hljl-oB'>-</span><span class='hljl-nf'>g</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-p'>))</span><span class='hljl-oB'>/</span><span class='hljl-n'>ϵ</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-nf'>cos</span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-n'>π</span><span class='hljl-oB'>*</span><span class='hljl-n'>t</span><span class='hljl-p'>))</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>t</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-oB'>:</span><span class='hljl-nfB'>1f-2</span><span class='hljl-oB'>:</span><span class='hljl-nfB'>1f0</span><span class='hljl-p'>)</span>
</pre> <pre class=julia-error >
ERROR: Failed to precompile Statistics &#91;10745b16-79ce-11e8-11f9-7d13ad32a3b2&#93; to &quot;/home/runner/.julia/compiled/v1.10/Statistics/jl_CDUMyN&quot;.
</pre> <p>would be minimized.</p> <pre class='hljl'>
<span class='hljl-n'>opt</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>Flux</span><span class='hljl-oB'>.</span><span class='hljl-nf'>Descent</span><span class='hljl-p'>(</span><span class='hljl-nfB'>0.01</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>data</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>Iterators</span><span class='hljl-oB'>.</span><span class='hljl-nf'>repeated</span><span class='hljl-p'>((),</span><span class='hljl-t'> </span><span class='hljl-ni'>5000</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>iter</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'>
</span><span class='hljl-n'>cb</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-p'>()</span><span class='hljl-t'> </span><span class='hljl-cs'>#callback function to observe training</span><span class='hljl-t'>
  </span><span class='hljl-kd'>global</span><span class='hljl-t'> </span><span class='hljl-n'>iter</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
  </span><span class='hljl-k'>if</span><span class='hljl-t'> </span><span class='hljl-n'>iter</span><span class='hljl-t'> </span><span class='hljl-oB'>%</span><span class='hljl-t'> </span><span class='hljl-ni'>500</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'>
    </span><span class='hljl-nf'>display</span><span class='hljl-p'>(</span><span class='hljl-nf'>loss</span><span class='hljl-p'>())</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nf'>display</span><span class='hljl-p'>(</span><span class='hljl-nf'>loss</span><span class='hljl-p'>())</span><span class='hljl-t'>
</span><span class='hljl-n'>Flux</span><span class='hljl-oB'>.</span><span class='hljl-nf'>train!</span><span class='hljl-p'>(</span><span class='hljl-n'>loss</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>Flux</span><span class='hljl-oB'>.</span><span class='hljl-nf'>params</span><span class='hljl-p'>(</span><span class='hljl-n'>NNODE</span><span class='hljl-p'>),</span><span class='hljl-t'> </span><span class='hljl-n'>data</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>opt</span><span class='hljl-p'>;</span><span class='hljl-t'> </span><span class='hljl-n'>cb</span><span class='hljl-oB'>=</span><span class='hljl-n'>cb</span><span class='hljl-p'>)</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;Flux&#96; not defined
</pre> <p>How well did this do? Well if we take the integral of both sides of our differential equation, we see it&#39;s fairly trivial:</p> <p class=math >\[ \int g' = g = \int \cos 2\pi t = C + \frac{\sin 2\pi t}{2\pi} \]</p> <p>where we defined <span class=math >$C = 1$</span>. Let&#39;s take a bunch of &#40;input,output&#41; pairs from the neural network and plot it against the analytical solution to the differential equation:</p> <pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>Plots</span><span class='hljl-t'>
</span><span class='hljl-n'>t</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-oB'>:</span><span class='hljl-nfB'>0.001</span><span class='hljl-oB'>:</span><span class='hljl-nfB'>1.0</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-p'>,</span><span class='hljl-n'>g</span><span class='hljl-oB'>.</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-p'>),</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;NN&quot;</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot!</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-t'> </span><span class='hljl-oB'>.+</span><span class='hljl-t'> </span><span class='hljl-n'>sin</span><span class='hljl-oB'>.</span><span class='hljl-p'>(</span><span class='hljl-ni'>2</span><span class='hljl-n'>π</span><span class='hljl-oB'>.*</span><span class='hljl-n'>t</span><span class='hljl-p'>)</span><span class='hljl-oB'>/</span><span class='hljl-ni'>2</span><span class='hljl-n'>π</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>label</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-s'>&quot;True Solution&quot;</span><span class='hljl-p'>)</span>
</pre> <pre class=julia-error >
ERROR: Failed to precompile Plots &#91;91a5bcdd-55d7-5caf-9e0b-520d859cae80&#93; to &quot;/home/runner/.julia/compiled/v1.10/Plots/jl_rrwNuv&quot;.
</pre> <p>We see that it matches very well, and we can keep improving this fit by increasing the size of the neural network, using more training points, and training for more iterations.</p> <h3>Example: Harmonic Oscillator Informed Training</h3> <p>Using this idea, differential equations encoding physical laws can be utilized inside of loss functions for terms which we have some basis to believe should approximately follow some physical system. Let&#39;s investigate this last step by looking at how to inform the training of a neural network using the harmonic oscillator.</p> <p>Let&#39;s assume that we are taking measurements of &#40;position,force&#41; in some real one-dimensional spring pushing and pulling against a wall.</p> <p><img src="https://thumbs.dreamstime.com/b/hookes-law-vector-illustration-physics-extend-spring-force-explanation-scheme-compress-mathematical-experiment-weight-177188357.jpg" alt="" /></p> <p>But instead of the simple spring, let&#39;s assume we had a more complex spring, for example, let&#39;s say <span class=math >$F(x) = -kx + 0.1sin(x)$</span> where this extra term is due to some deformities in the metal &#40;assume mass&#61;1&#41;. Then by Newton&#39;s law of motion we have a second order ordinary differential equation:</p> <p class=math >\[ x'' = -kx + 0.1 \sin(x) \]</p> <p>We can use the <a href="https://diffeq.sciml.ai/stable/">DifferentialEquations.jl package</a> to solve this differential equation and see what this system looks like:</p> <pre class='hljl'>
<span class='hljl-k'>using</span><span class='hljl-t'> </span><span class='hljl-n'>DifferentialEquations</span><span class='hljl-t'>
</span><span class='hljl-n'>k</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nfB'>1.0</span><span class='hljl-t'>
</span><span class='hljl-nf'>force</span><span class='hljl-p'>(</span><span class='hljl-n'>dx</span><span class='hljl-p'>,</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>k</span><span class='hljl-p'>,</span><span class='hljl-n'>t</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-n'>k</span><span class='hljl-oB'>*</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-nfB'>0.1</span><span class='hljl-nf'>sin</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>prob</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>SecondOrderODEProblem</span><span class='hljl-p'>(</span><span class='hljl-n'>force</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>0.0</span><span class='hljl-p'>,(</span><span class='hljl-nfB'>0.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>10.0</span><span class='hljl-p'>),</span><span class='hljl-n'>k</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>sol</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>solve</span><span class='hljl-p'>(</span><span class='hljl-n'>prob</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>sol</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-p'>[</span><span class='hljl-s'>&quot;Velocity&quot;</span><span class='hljl-t'> </span><span class='hljl-s'>&quot;Position&quot;</span><span class='hljl-p'>])</span>
</pre> <pre class=julia-error >
ERROR: Failed to precompile DifferentialEquations &#91;0c46a032-eb83-5123-abaf-570d42b7fbaa&#93; to &quot;/home/runner/.julia/compiled/v1.10/DifferentialEquations/jl_EWcTNm&quot;.
</pre> <p>Don&#39;t worry if you don&#39;t understand this syntax yet: we will go over differential equation solvers and DifferentialEquations.jl in a later lecture.</p> <p>Let&#39;s say we want to learn how to predict the force applied on the spring at each point in space, <span class=math >$F(x)$</span>. We want to learn a function, so this is the job for machine learning&#33; However, we only have 6 measurements, which includes the information about &#40;position,velocity,force&#41; at evenly spaced times:</p> <pre class='hljl'>
<span class='hljl-n'>plot_t</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-oB'>:</span><span class='hljl-nfB'>0.01</span><span class='hljl-oB'>:</span><span class='hljl-ni'>10</span><span class='hljl-t'>
</span><span class='hljl-n'>data_plot</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>sol</span><span class='hljl-p'>(</span><span class='hljl-n'>plot_t</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>positions_plot</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>state</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>state</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>data_plot</span><span class='hljl-p'>]</span><span class='hljl-t'>
</span><span class='hljl-n'>force_plot</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nf'>force</span><span class='hljl-p'>(</span><span class='hljl-n'>state</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>],</span><span class='hljl-n'>state</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>],</span><span class='hljl-n'>k</span><span class='hljl-p'>,</span><span class='hljl-n'>t</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>state</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>data_plot</span><span class='hljl-p'>]</span><span class='hljl-t'>

</span><span class='hljl-cs'># Generate the dataset</span><span class='hljl-t'>
</span><span class='hljl-n'>t</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-oB'>:</span><span class='hljl-nfB'>3.3</span><span class='hljl-oB'>:</span><span class='hljl-ni'>10</span><span class='hljl-t'>
</span><span class='hljl-n'>dataset</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>sol</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>position_data</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>state</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>state</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-nf'>sol</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-p'>)]</span><span class='hljl-t'>
</span><span class='hljl-n'>force_data</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-nf'>force</span><span class='hljl-p'>(</span><span class='hljl-n'>state</span><span class='hljl-p'>[</span><span class='hljl-ni'>1</span><span class='hljl-p'>],</span><span class='hljl-n'>state</span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-p'>],</span><span class='hljl-n'>k</span><span class='hljl-p'>,</span><span class='hljl-n'>t</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>state</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-nf'>sol</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-p'>)]</span><span class='hljl-t'>

</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>plot_t</span><span class='hljl-p'>,</span><span class='hljl-n'>force_plot</span><span class='hljl-p'>,</span><span class='hljl-n'>xlabel</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;t&quot;</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;True Force&quot;</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>scatter!</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-p'>,</span><span class='hljl-n'>force_data</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;Force Measurements&quot;</span><span class='hljl-p'>)</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;sol&#96; not defined
</pre> <p>Can we train a neural network to approximate the expected force at any location for this spring? To see whether this is possible with a standard neural network, let&#39;s just do it. Let&#39;s define a neural network to be <span class=math >$F(x)$</span> and see if we can learn the force function&#33;</p> <pre class='hljl'>
<span class='hljl-n'>NNForce</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>Chain</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-oB'>-&gt;</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-n'>x</span><span class='hljl-p'>],</span><span class='hljl-t'>
           </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>1</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>32</span><span class='hljl-p'>,</span><span class='hljl-n'>tanh</span><span class='hljl-p'>),</span><span class='hljl-t'>
           </span><span class='hljl-nf'>Dense</span><span class='hljl-p'>(</span><span class='hljl-ni'>32</span><span class='hljl-t'> </span><span class='hljl-oB'>=&gt;</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-p'>),</span><span class='hljl-t'>
           </span><span class='hljl-n'>first</span><span class='hljl-p'>)</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;Dense&#96; not defined
</pre> <p>Now our loss function will be to match the force at the &#40;position,force&#41; pairs in the dataset:</p> <pre class='hljl'>
<span class='hljl-nf'>loss</span><span class='hljl-p'>()</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>sum</span><span class='hljl-p'>(</span><span class='hljl-n'>abs2</span><span class='hljl-p'>,</span><span class='hljl-nf'>NNForce</span><span class='hljl-p'>(</span><span class='hljl-n'>position_data</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>])</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-n'>force_data</span><span class='hljl-p'>[</span><span class='hljl-n'>i</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-nf'>length</span><span class='hljl-p'>(</span><span class='hljl-n'>position_data</span><span class='hljl-p'>))</span><span class='hljl-t'>
</span><span class='hljl-nf'>loss</span><span class='hljl-p'>()</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;position_data&#96; not defined
</pre> <p>Our random parameters do not do so well, so let&#39;s train&#33;</p> <pre class='hljl'>
<span class='hljl-n'>opt</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>Flux</span><span class='hljl-oB'>.</span><span class='hljl-nf'>Descent</span><span class='hljl-p'>(</span><span class='hljl-nfB'>0.01</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>data</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>Iterators</span><span class='hljl-oB'>.</span><span class='hljl-nf'>repeated</span><span class='hljl-p'>((),</span><span class='hljl-t'> </span><span class='hljl-ni'>5000</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>iter</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'>
</span><span class='hljl-n'>cb</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-p'>()</span><span class='hljl-t'> </span><span class='hljl-cs'>#callback function to observe training</span><span class='hljl-t'>
  </span><span class='hljl-kd'>global</span><span class='hljl-t'> </span><span class='hljl-n'>iter</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
  </span><span class='hljl-k'>if</span><span class='hljl-t'> </span><span class='hljl-n'>iter</span><span class='hljl-t'> </span><span class='hljl-oB'>%</span><span class='hljl-t'> </span><span class='hljl-ni'>500</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'>
    </span><span class='hljl-nf'>display</span><span class='hljl-p'>(</span><span class='hljl-nf'>loss</span><span class='hljl-p'>())</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nf'>display</span><span class='hljl-p'>(</span><span class='hljl-nf'>loss</span><span class='hljl-p'>())</span><span class='hljl-t'>
</span><span class='hljl-n'>Flux</span><span class='hljl-oB'>.</span><span class='hljl-nf'>train!</span><span class='hljl-p'>(</span><span class='hljl-n'>loss</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>Flux</span><span class='hljl-oB'>.</span><span class='hljl-nf'>params</span><span class='hljl-p'>(</span><span class='hljl-n'>NNForce</span><span class='hljl-p'>),</span><span class='hljl-t'> </span><span class='hljl-n'>data</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>opt</span><span class='hljl-p'>;</span><span class='hljl-t'> </span><span class='hljl-n'>cb</span><span class='hljl-oB'>=</span><span class='hljl-n'>cb</span><span class='hljl-p'>)</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;Flux&#96; not defined
</pre> <p>The neural network almost exactly matched the dataset, but how well did it actually learn the real force function? Let&#39;s plot it to see:</p> <pre class='hljl'>
<span class='hljl-n'>learned_force_plot</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>NNForce</span><span class='hljl-oB'>.</span><span class='hljl-p'>(</span><span class='hljl-n'>positions_plot</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>plot_t</span><span class='hljl-p'>,</span><span class='hljl-n'>force_plot</span><span class='hljl-p'>,</span><span class='hljl-n'>xlabel</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;t&quot;</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;True Force&quot;</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot!</span><span class='hljl-p'>(</span><span class='hljl-n'>plot_t</span><span class='hljl-p'>,</span><span class='hljl-n'>learned_force_plot</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;Predicted Force&quot;</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>scatter!</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-p'>,</span><span class='hljl-n'>force_data</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;Force Measurements&quot;</span><span class='hljl-p'>)</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;NNForce&#96; not defined
</pre> <p>Ouch. The problem is that a neural network can approximate any function, so it approximated <em>a</em> function that fits the data, but not <em>the correct</em> function. We somehow need to have more data... but where can we get more data?</p> <p>Well, even a first year undergrad in physics will know Hooke&#39;s law, which is that the idealized spring should satisfy <span class=math >$F(x) = -kx$</span>. This is a decent assumption for the evolution of the system:</p> <pre class='hljl'>
<span class='hljl-nf'>force2</span><span class='hljl-p'>(</span><span class='hljl-n'>dx</span><span class='hljl-p'>,</span><span class='hljl-n'>x</span><span class='hljl-p'>,</span><span class='hljl-n'>k</span><span class='hljl-p'>,</span><span class='hljl-n'>t</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-n'>k</span><span class='hljl-oB'>*</span><span class='hljl-n'>x</span><span class='hljl-t'>
</span><span class='hljl-n'>prob_simplified</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>SecondOrderODEProblem</span><span class='hljl-p'>(</span><span class='hljl-n'>force2</span><span class='hljl-p'>,</span><span class='hljl-nfB'>1.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>0.0</span><span class='hljl-p'>,(</span><span class='hljl-nfB'>0.0</span><span class='hljl-p'>,</span><span class='hljl-nfB'>10.0</span><span class='hljl-p'>),</span><span class='hljl-n'>k</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>sol_simplified</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>solve</span><span class='hljl-p'>(</span><span class='hljl-n'>prob_simplified</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>sol</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-p'>[</span><span class='hljl-s'>&quot;Velocity&quot;</span><span class='hljl-t'> </span><span class='hljl-s'>&quot;Position&quot;</span><span class='hljl-p'>])</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot!</span><span class='hljl-p'>(</span><span class='hljl-n'>sol_simplified</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-p'>[</span><span class='hljl-s'>&quot;Velocity Simplified&quot;</span><span class='hljl-t'> </span><span class='hljl-s'>&quot;Position Simplified&quot;</span><span class='hljl-p'>])</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;SecondOrderODEProblem&#96; not defined
</pre> <p>While it&#39;s not quite correct, and it definitely drifts near the end, it should be a useful non-data assumption that we can add to improve the fitting. So, assuming we know <span class=math >$k$</span> &#40;this lab you probably have done before&#33;&#41;, we can regularize this fitting by having a term that states our neural network should be the solution to the differential equation.</p> <p>This term looks like what we had done before:</p> <pre class='hljl'>
<span class='hljl-n'>random_positions</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-p'>[</span><span class='hljl-ni'>2</span><span class='hljl-nf'>rand</span><span class='hljl-p'>()</span><span class='hljl-oB'>-</span><span class='hljl-ni'>1</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>i</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-oB'>:</span><span class='hljl-ni'>100</span><span class='hljl-p'>]</span><span class='hljl-t'> </span><span class='hljl-cs'># random values in [-1,1]</span><span class='hljl-t'>
</span><span class='hljl-nf'>loss_ode</span><span class='hljl-p'>()</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>sum</span><span class='hljl-p'>(</span><span class='hljl-n'>abs2</span><span class='hljl-p'>,</span><span class='hljl-nf'>NNForce</span><span class='hljl-p'>(</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-oB'>-</span><span class='hljl-t'> </span><span class='hljl-p'>(</span><span class='hljl-oB'>-</span><span class='hljl-n'>k</span><span class='hljl-oB'>*</span><span class='hljl-n'>x</span><span class='hljl-p'>)</span><span class='hljl-t'> </span><span class='hljl-k'>for</span><span class='hljl-t'> </span><span class='hljl-n'>x</span><span class='hljl-t'> </span><span class='hljl-kp'>in</span><span class='hljl-t'> </span><span class='hljl-n'>random_positions</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>loss_ode</span><span class='hljl-p'>()</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;NNForce&#96; not defined
</pre> <p>If this term is zero, then <span class=math >$F(x) = -kx$</span>, which is approximately true. So now let&#39;s put these together:</p> <pre class='hljl'>
<span class='hljl-n'>λ</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nfB'>0.1</span><span class='hljl-t'>
</span><span class='hljl-nf'>composed_loss</span><span class='hljl-p'>()</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-nf'>loss</span><span class='hljl-p'>()</span><span class='hljl-t'> </span><span class='hljl-oB'>+</span><span class='hljl-t'> </span><span class='hljl-n'>λ</span><span class='hljl-oB'>*</span><span class='hljl-nf'>loss_ode</span><span class='hljl-p'>()</span>
</pre> <pre class=output >
composed_loss &#40;generic function with 1 method&#41;
</pre> <p>where <span class=math >$λ$</span> is some weight factor to control the regularization against the physics assumption. Now we can train the physics-informed neural network:</p> <pre class='hljl'>
<span class='hljl-n'>opt</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>Flux</span><span class='hljl-oB'>.</span><span class='hljl-nf'>Descent</span><span class='hljl-p'>(</span><span class='hljl-nfB'>0.01</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>data</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>Iterators</span><span class='hljl-oB'>.</span><span class='hljl-nf'>repeated</span><span class='hljl-p'>((),</span><span class='hljl-t'> </span><span class='hljl-ni'>5000</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-n'>iter</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'>
</span><span class='hljl-n'>cb</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-k'>function</span><span class='hljl-t'> </span><span class='hljl-p'>()</span><span class='hljl-t'> </span><span class='hljl-cs'>#callback function to observe training</span><span class='hljl-t'>
  </span><span class='hljl-kd'>global</span><span class='hljl-t'> </span><span class='hljl-n'>iter</span><span class='hljl-t'> </span><span class='hljl-oB'>+=</span><span class='hljl-t'> </span><span class='hljl-ni'>1</span><span class='hljl-t'>
  </span><span class='hljl-k'>if</span><span class='hljl-t'> </span><span class='hljl-n'>iter</span><span class='hljl-t'> </span><span class='hljl-oB'>%</span><span class='hljl-t'> </span><span class='hljl-ni'>500</span><span class='hljl-t'> </span><span class='hljl-oB'>==</span><span class='hljl-t'> </span><span class='hljl-ni'>0</span><span class='hljl-t'>
    </span><span class='hljl-nf'>display</span><span class='hljl-p'>(</span><span class='hljl-nf'>composed_loss</span><span class='hljl-p'>())</span><span class='hljl-t'>
  </span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-k'>end</span><span class='hljl-t'>
</span><span class='hljl-nf'>display</span><span class='hljl-p'>(</span><span class='hljl-nf'>composed_loss</span><span class='hljl-p'>())</span><span class='hljl-t'>
</span><span class='hljl-n'>Flux</span><span class='hljl-oB'>.</span><span class='hljl-nf'>train!</span><span class='hljl-p'>(</span><span class='hljl-n'>composed_loss</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>Flux</span><span class='hljl-oB'>.</span><span class='hljl-nf'>params</span><span class='hljl-p'>(</span><span class='hljl-n'>NNForce</span><span class='hljl-p'>),</span><span class='hljl-t'> </span><span class='hljl-n'>data</span><span class='hljl-p'>,</span><span class='hljl-t'> </span><span class='hljl-n'>opt</span><span class='hljl-p'>;</span><span class='hljl-t'> </span><span class='hljl-n'>cb</span><span class='hljl-oB'>=</span><span class='hljl-n'>cb</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-n'>learned_force_plot</span><span class='hljl-t'> </span><span class='hljl-oB'>=</span><span class='hljl-t'> </span><span class='hljl-n'>NNForce</span><span class='hljl-oB'>.</span><span class='hljl-p'>(</span><span class='hljl-n'>positions_plot</span><span class='hljl-p'>)</span><span class='hljl-t'>

</span><span class='hljl-nf'>plot</span><span class='hljl-p'>(</span><span class='hljl-n'>plot_t</span><span class='hljl-p'>,</span><span class='hljl-n'>force_plot</span><span class='hljl-p'>,</span><span class='hljl-n'>xlabel</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;t&quot;</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;True Force&quot;</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>plot!</span><span class='hljl-p'>(</span><span class='hljl-n'>plot_t</span><span class='hljl-p'>,</span><span class='hljl-n'>learned_force_plot</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;Predicted Force&quot;</span><span class='hljl-p'>)</span><span class='hljl-t'>
</span><span class='hljl-nf'>scatter!</span><span class='hljl-p'>(</span><span class='hljl-n'>t</span><span class='hljl-p'>,</span><span class='hljl-n'>force_data</span><span class='hljl-p'>,</span><span class='hljl-n'>label</span><span class='hljl-oB'>=</span><span class='hljl-s'>&quot;Force Measurements&quot;</span><span class='hljl-p'>)</span>
</pre> <pre class=julia-error >
ERROR: UndefVarError: &#96;Flux&#96; not defined
</pre> <p>And there we go: we have used knowledge of physics to help inform our neural network training process&#33;</p> <h2>Conclusion</h2> <p>In this lecture we motivated machine learning not as a process of predicting from data but as a process for learning arbitrary nonlinear functions. Neural networks were just one choice of possible function. We then demonstrated how differential equations could be solved using this function approximation technique and then put together these two domains, solving differential equations and approximating data, into a single process to allow for physical knowledge to be embedded into the training process of a neural network, thus arriving at a physics-informed neural network. This is just one method in scientific machine learning which we will be exploring in more detail, demonstrating how we can utilize scientific knowledge to improve fits and allow for data-efficient machine learning.</p> <div class=footer > <p> Published from <a href=sciml.jmd >sciml.jmd</a> using <a href="http://github.com/JunoLab/Weave.jl">Weave.jl</a> v0.10.9 on 2024-04-09. </p> </div>